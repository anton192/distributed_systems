# Задние 3


## Постановка задачи

Реализовать алгоритм Token ring. С обработкой ситуации потери сообщения

## Идея реализации

На каждом узле будем хранить его состояние и в каждом сообщении будем передавать 
его тип (всего возможно тоько 3 типа: сообщение, подтверждение, пустой маркер).
И будем выбирать дальнейшее действие с сообщением из комбинации этих двух параметров.

## Реализация проверок

При отправке сообщения (смыслового) заведем еще одну задачу, которая будет спать
полный цикл, а потом проснется и проверит произошло ли что-то новое на данном
узле. Для этого на каждом узле будем хранить время последнего обработанного сообщения. 
Если на узле за время полного цикла ничего не произошо - значит токен где-то потерялся.
В таком случае посылаем сообщение заново.

Заметим, что описанная выше проверка не рассматривает случай потери пустого токена.
Для обработки этой ситуации запустим похожий механизм на нулевом узле. В случае
обнаружения пропажи токена этот процесс будет посылть пустой токен на нулевой узел.

## Возможные примеры запуска

Просто отправить одно сообщение (с 3-го узла 7-му)

		msg := SysMsg {
		    Type: "send",
		    Dst: 7,
		    Data: "data"}
		text_msg, _ := json.Marshal(msg)
		send_message(PORT_COMMAND + 3, text_msg)

Отправить сообщение, которое потеряется по дороге

		msg := SysMsg {
		    Type: "send",
		    Dst: 7,
		    Data: "data"}
		text_msg, _ := json.Marshal(msg)
		send_message(PORT_COMMAND + 3, text_msg)

		msg = SysMsg {
		    Type: "drop",
		    Dst: 0,
		    Data: ""}
		text_msg, _ = json.Marshal(msg)
		send_message(PORT_COMMAND + 5, text_msg)

Создать очередь сообщений

		msg := SysMsg {
		    Type: "send",
		    Dst: 7,
		    Data: "data"}
		text_msg, _ := json.Marshal(msg)
		send_message(PORT_COMMAND + 3, text_msg)
		send_message(PORT_COMMAND + 3, text_msg)

# Запуск программы

Пример запуска `go run main.go -n 10 -t 100`

Где
+ `-n` - количество процессов
+ `-t` - время удержания токена в милисекундах
